<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Crypto Sentinel Pro - Dashboard de sentiment crypto avec Fear & Greed Index">
  <meta name="theme-color" content="#070d1a">
  <title>Crypto Sentinel Pro</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìä</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            sans: ['Inter', 'system-ui', '-apple-system', 'sans-serif'],
            mono: ['JetBrains Mono', 'Fira Code', 'monospace'],
          },
          colors: {
            dark: { 900: '#070d1a', 800: '#0a1628', 700: '#0d1f38', 600: '#0f2744', 500: '#142d4c', 400: '#1a3656', 300: '#1e3a5f', 200: '#2a4a6f', 100: '#3a5a7f' },
            accent: { red: '#ea3943', orange: '#ea8c00', yellow: '#c9b003', lime: '#93d900', green: '#16c784', emerald: '#22c55e', blue: '#3b82f6', purple: '#a855f7', cyan: '#06b6d4' }
          }
        }
      }
    }
  </script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: 'Inter', system-ui, -apple-system, sans-serif; background: #070d1a; overflow-x: hidden; }

    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: rgba(30, 58, 95, 0.6); border-radius: 8px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(42, 74, 111, 0.8); }

    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
    @keyframes glow { 0%, 100% { filter: drop-shadow(0 0 6px currentColor); } 50% { filter: drop-shadow(0 0 14px currentColor); } }
    @keyframes fadeInUp { from { opacity: 0; transform: translateY(16px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes shimmer { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }
    @keyframes float { 0%, 100% { transform: translateY(0px); } 50% { transform: translateY(-4px); } }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    .animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
    .animate-glow { animation: glow 3s ease-in-out infinite; }
    .animate-fadeInUp { animation: fadeInUp 0.5s ease-out both; }
    .animate-shimmer { background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.04) 50%, transparent 100%); background-size: 200% 100%; animation: shimmer 3s ease-in-out infinite; }
    .animate-float { animation: float 6s ease-in-out infinite; }
    .animate-spin { animation: spin 1s linear infinite; }

    .glass { background: rgba(15, 39, 68, 0.5); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); border: 1px solid rgba(30, 58, 95, 0.5); }
    .glass-light { background: rgba(26, 54, 86, 0.4); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); border: 1px solid rgba(30, 58, 95, 0.3); }

    .card-hover { transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
    .card-hover:hover { transform: translateY(-2px); border-color: rgba(59, 130, 246, 0.3); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(59, 130, 246, 0.1); }

    .text-gradient { background: linear-gradient(135deg, #3b82f6, #06b6d4, #16c784); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }

    .bg-grid { background-image: radial-gradient(rgba(30, 58, 95, 0.3) 1px, transparent 1px); background-size: 24px 24px; }

    .progress-bar { position: relative; overflow: hidden; }
    .progress-bar::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent); animation: shimmer 2s ease-in-out infinite; }

    .noise-bg { position: relative; }
    .noise-bg::before { content: ''; position: absolute; inset: 0; opacity: 0.02; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E"); pointer-events: none; z-index: 0; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo, useCallback } = React;

    // ========== CONFIGURATION ==========
    const CONFIG = {
      REFRESH_RATE: 60000, // 60s
      FNG_API: 'https://api.alternative.me/fng/',
      COINCAP_API: 'https://api.coincap.io/v2',
      CACHE_KEY: 'csp_cache_v3',
    };

    // ========== CLASSIFICATIONS ==========
    const getFearGreedClass = (v) => {
      if (v <= 24) return { label: 'Extreme Fear', color: '#ea3943', bg: 'rgba(234,57,67,0.12)', emoji: 'üò±', desc: 'Capitulation - Opportunit√© contrarian' };
      if (v <= 44) return { label: 'Fear', color: '#ea8c00', bg: 'rgba(234,140,0,0.12)', emoji: 'üò∞', desc: 'Sentiment n√©gatif dominant' };
      if (v <= 55) return { label: 'Neutral', color: '#c9b003', bg: 'rgba(201,176,3,0.12)', emoji: 'üòê', desc: 'March√© ind√©cis' };
      if (v <= 74) return { label: 'Greed', color: '#93d900', bg: 'rgba(147,217,0,0.12)', emoji: 'üòä', desc: 'Optimisme & FOMO' };
      return { label: 'Extreme Greed', color: '#16c784', bg: 'rgba(22,199,132,0.12)', emoji: 'ü§ë', desc: 'Euphorie - Correction probable' };
    };

    const getOppClass = (v) => {
      if (v <= 20) return { label: '√âVITER', color: '#ea3943', emoji: 'üö´', desc: 'Conditions d√©favorables' };
      if (v <= 40) return { label: 'PRUDENCE', color: '#ea8c00', emoji: '‚ö†Ô∏è', desc: 'Attendre de meilleures conditions' };
      if (v <= 60) return { label: 'NEUTRE', color: '#c9b003', emoji: 'üòê', desc: 'Conditions moyennes' };
      if (v <= 80) return { label: 'FAVORABLE', color: '#93d900', emoji: '‚úÖ', desc: 'Bonnes conditions d\'entr√©e' };
      return { label: 'EXCELLENT', color: '#16c784', emoji: 'üéØ', desc: 'Conditions optimales' };
    };

    const getSentimentStyle = (v) => {
      if (v <= 30) return { color: '#ea3943', label: 'BEARISH' };
      if (v <= 50) return { color: '#ea8c00', label: 'NEUTRE' };
      if (v <= 70) return { color: '#93d900', label: 'BULLISH' };
      return { color: '#16c784', label: 'V.BULLISH' };
    };

    // ========== CACHE HELPER ==========
    const saveCache = (key, data) => {
      try {
        localStorage.setItem(CONFIG.CACHE_KEY + '_' + key, JSON.stringify({ ts: Date.now(), data }));
      } catch (e) { console.warn('Cache save failed:', e); }
    };
    const loadCache = (key) => {
      try {
        const raw = localStorage.getItem(CONFIG.CACHE_KEY + '_' + key);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        // Return cached data even if stale (better than nothing)
        return parsed.data;
      } catch (e) { return null; }
    };

    // ========== RETRY HELPER ==========
    const fetchWithRetry = async (fetchFn, retries = 2, delay = 3000) => {
      for (let attempt = 1; attempt <= retries; attempt++) {
        const result = await fetchFn();
        if (result !== null) return result;
        if (attempt < retries) {
          console.warn(`Tentative ${attempt}/${retries} √©chou√©e, retry dans ${delay/1000}s...`);
          await new Promise(r => setTimeout(r, delay * attempt));
        }
      }
      return null;
    };

    // Small delay helper to stagger API calls and avoid rate limits
    const wait = (ms) => new Promise(r => setTimeout(r, ms));

    // ========== REAL API FETCHERS ==========

    // Fetch Fear & Greed Index (current + history) ‚Äî Alternative.me
    const fetchFearGreedData = async () => {
      try {
        const res = await fetch(`${CONFIG.FNG_API}?limit=731&format=json&date_format=world`);
        if (!res.ok) throw new Error(`FNG API error: ${res.status}`);
        const json = await res.json();
        const data = json.data.reverse().map(d => ({
          ts: parseInt(d.timestamp),
          value: parseInt(d.value),
          classification: d.value_classification,
          date: new Date(parseInt(d.timestamp) * 1000).toISOString().split('T')[0]
        }));
        saveCache('fg', data);
        return data;
      } catch (err) {
        console.error('Fear & Greed fetch error:', err);
        return null;
      }
    };

    // Fetch BTC price history ‚Äî CoinCap API
    const fetchBtcHistory = async () => {
      try {
        const end = Date.now();
        const start = end - (730 * 24 * 60 * 60 * 1000);
        const res = await fetch(`${CONFIG.COINCAP_API}/assets/bitcoin/history?interval=d1&start=${start}&end=${end}`);
        if (!res.ok) throw new Error(`CoinCap BTC history error: ${res.status}`);
        const json = await res.json();
        const data = json.data.map(d => ({
          ts: Math.floor(d.time / 1000),
          price: parseFloat(d.priceUsd)
        }));
        saveCache('btc', data);
        return data;
      } catch (err) {
        console.error('BTC history fetch error:', err);
        return null;
      }
    };

    // Fetch Top 100 cryptos ‚Äî CoinCap API
    const fetchCryptos = async () => {
      try {
        const res = await fetch(`${CONFIG.COINCAP_API}/assets?limit=100`);
        if (!res.ok) throw new Error(`CoinCap assets error: ${res.status}`);
        const json = await res.json();
        if (!json.data || !Array.isArray(json.data)) throw new Error('Invalid response format');
        const data = json.data.map((coin, i) => ({
          id: i + 1,
          cgId: coin.id,
          sym: coin.symbol,
          name: coin.name,
          image: `https://assets.coincap.io/assets/icons/${coin.symbol.toLowerCase()}@2x.png`,
          price: parseFloat(coin.priceUsd) || 0,
          marketCap: parseFloat(coin.marketCapUsd) || 0,
          volume24h: parseFloat(coin.volumeUsd24Hr) || 0,
          c24: parseFloat(coin.changePercent24Hr) || 0,
          c7: 0,
          c30: 0,
          c1h: 0,
          ath: 0,
          athChange: 0,
          sparkline: [],
          vwap24Hr: parseFloat(coin.vwap24Hr) || 0,
          supply: parseFloat(coin.supply) || 0,
          maxSupply: parseFloat(coin.maxSupply) || 0,
        }));
        saveCache('cryptos', data);
        return data;
      } catch (err) {
        console.error('Crypto fetch error:', err);
        return null;
      }
    };

    // Fetch 7d history for top coins to compute 7d/30d changes
    const enrichCryptosWithHistory = async (cryptos) => {
      if (!cryptos || cryptos.length === 0) return cryptos;
      const end = Date.now();
      const start30d = end - (30 * 24 * 60 * 60 * 1000);
      // Only fetch history for top 20 to limit API calls
      const topIds = cryptos.slice(0, 20).map(c => c.cgId);
      const enriched = [...cryptos];

      for (let idx = 0; idx < topIds.length; idx++) {
        try {
          const res = await fetch(`${CONFIG.COINCAP_API}/assets/${topIds[idx]}/history?interval=d1&start=${start30d}&end=${end}`);
          if (!res.ok) continue;
          const json = await res.json();
          if (!json.data || json.data.length < 2) continue;

          const prices = json.data.map(d => parseFloat(d.priceUsd));
          const currentPrice = prices[prices.length - 1];
          const price7dAgo = prices.length >= 7 ? prices[prices.length - 7] : prices[0];
          const price30dAgo = prices[0];

          enriched[idx].c7 = ((currentPrice - price7dAgo) / price7dAgo) * 100;
          enriched[idx].c30 = ((currentPrice - price30dAgo) / price30dAgo) * 100;
          enriched[idx].sparkline = prices.slice(-7);

          // Estimate ATH from available data
          const maxPrice = Math.max(...prices);
          enriched[idx].ath = maxPrice;
          enriched[idx].athChange = ((currentPrice - maxPrice) / maxPrice) * 100;
        } catch (e) { /* skip enrichment for this coin */ }
      }

      saveCache('cryptos', enriched);
      return enriched;
    };

    // ========== SENTIMENT CALCULATOR ==========
    // Compute a sentiment score (0-100) from real market data
    const computeSentiment = (coin) => {
      // Factor 1: 24h price change (primary signal)
      const c24Contrib = Math.max(0, Math.min(100, 50 + (coin.c24 || 0) * 5));

      // Factor 2: 7d price change (if available)
      const has7d = coin.c7 !== 0;
      const c7Contrib = has7d ? Math.max(0, Math.min(100, 50 + coin.c7 * 3)) : c24Contrib;

      // Factor 3: 30d price change (if available)
      const has30d = coin.c30 !== 0;
      const c30Contrib = has30d ? Math.max(0, Math.min(100, 50 + coin.c30 * 1.5)) : c24Contrib;

      // Factor 4: Volume/VWAP signal
      const vwapSignal = coin.vwap24Hr > 0 && coin.price > 0
        ? Math.max(0, Math.min(100, 50 + ((coin.price - coin.vwap24Hr) / coin.vwap24Hr) * 200))
        : (coin.c24 >= 0 ? 60 : 40);

      // Factor 5: Market rank signal (top coins tend to be more stable)
      const rankSignal = coin.id <= 10 ? 55 : coin.id <= 30 ? 50 : 45;

      // Weighted average - adapt weights based on available data
      const w24 = 0.35;
      const w7 = has7d ? 0.25 : 0.10;
      const w30 = has30d ? 0.15 : 0.05;
      const wVwap = 0.15;
      const wRank = 1 - w24 - w7 - w30 - wVwap;

      const score = Math.round(
        c24Contrib * w24 +
        c7Contrib * w7 +
        c30Contrib * w30 +
        vwapSignal * wVwap +
        rankSignal * wRank
      );

      return Math.max(0, Math.min(100, score));
    };

    // Compute trend from sparkline or 24h change
    const computeFlow = (coin) => {
      if (coin.sparkline && coin.sparkline.length >= 4) {
        const recent = coin.sparkline.slice(-3);
        const older = coin.sparkline.slice(0, 3);
        const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
        const olderAvg = older.reduce((a, b) => a + b, 0) / older.length;
        if (olderAvg === 0) return 0;
        return Math.round(((recentAvg - olderAvg) / olderAvg) * 1000) / 10;
      }
      // Fallback: use 24h change as trend proxy
      return Math.round((coin.c24 || 0) * 10) / 10;
    };

    // ========== BACKTEST OPTIMIZATION ENGINE ==========
    // Runs on historical F&G + BTC data to find optimal weight combination
    const runBacktestOptimization = (fgHistory, btcHistory) => {
      if (!fgHistory || fgHistory.length < 90 || !btcHistory || btcHistory.length < 90) {
        return { weights: [18, 24, 20, 16, 22], accuracy: 0, tested: 0 };
      }

      // Align data: match F&G dates with BTC prices
      const btcMap = {};
      btcHistory.forEach(b => { btcMap[Math.floor(b.ts / 86400)] = b.price; });

      const aligned = fgHistory.map(fg => {
        const dayKey = Math.floor(fg.ts / 86400);
        return { fg: fg.value, price: btcMap[dayKey] || btcMap[dayKey - 1] || btcMap[dayKey + 1] || 0 };
      }).filter(d => d.price > 0);

      if (aligned.length < 60) return { weights: [18, 24, 20, 16, 22], accuracy: 0, tested: 0 };

      // Compute derived signals for each day
      const signals = [];
      for (let i = 30; i < aligned.length - 14; i++) {
        const fg = aligned[i].fg;
        const price = aligned[i].price;
        const price30ago = aligned[i - 30].price;
        const price7ago = aligned[i - 7].price;

        // Signal 1: F&G contrarian
        const s1 = fg <= 25 ? 85 : fg <= 40 ? 70 : fg <= 55 ? 50 : fg <= 75 ? 35 : 15;

        // Signal 2: Price momentum (30d relative)
        const mom30 = ((price - price30ago) / price30ago) * 100;
        const s2 = Math.max(0, Math.min(100, 50 + mom30 * 2.5));

        // Signal 3: Trend strength (7d)
        const mom7 = ((price - price7ago) / price7ago) * 100;
        const s3 = Math.max(0, Math.min(100, 50 + mom7 * 5));

        // Signal 4: Volatility (7d std dev proxy)
        const window = aligned.slice(i - 7, i).map(d => d.price);
        const mean = window.reduce((a, b) => a + b, 0) / window.length;
        const variance = window.reduce((s, p) => s + Math.pow(p - mean, 2), 0) / window.length;
        const volatility = (Math.sqrt(variance) / mean) * 100;
        const s4 = volatility < 1.5 ? 40 : volatility < 3 ? 80 : volatility < 6 ? 60 : 20;

        // Signal 5: Mean reversion (deviation from 30d avg)
        const avg30 = aligned.slice(i - 30, i).reduce((s, d) => s + d.price, 0) / 30;
        const deviation = ((price - avg30) / avg30) * 100;
        const s5 = deviation < -10 ? 85 : deviation < -3 ? 65 : deviation < 3 ? 50 : deviation < 10 ? 35 : 15;

        // Future return (14 days ahead) - what we're trying to predict
        const futurePrice = aligned[i + 14].price;
        const futureReturn = ((futurePrice - price) / price) * 100;

        signals.push({ s1, s2, s3, s4, s5, futureReturn });
      }

      if (signals.length < 30) return { weights: [18, 24, 20, 16, 22], accuracy: 0, tested: 0 };

      // Grid search: test weight combinations (step=4, sums to ~100)
      let bestWeights = [20, 20, 20, 20, 20];
      let bestCorrelation = -Infinity;
      let tested = 0;

      const step = 4;
      for (let w1 = 8; w1 <= 36; w1 += step) {
        for (let w2 = 8; w2 <= 36; w2 += step) {
          for (let w3 = 8; w3 <= 36; w3 += step) {
            for (let w4 = 8; w4 <= 36; w4 += step) {
              const w5 = 100 - w1 - w2 - w3 - w4;
              if (w5 < 4 || w5 > 40) continue;
              tested++;

              // Compute composite scores + correlation with future returns
              let sumXY = 0, sumX = 0, sumY = 0, sumX2 = 0, sumY2 = 0;
              const n = signals.length;

              for (const sig of signals) {
                const composite = (sig.s1 * w1 + sig.s2 * w2 + sig.s3 * w3 + sig.s4 * w4 + sig.s5 * w5) / 100;
                const ret = sig.futureReturn;
                sumXY += composite * ret;
                sumX += composite;
                sumY += ret;
                sumX2 += composite * composite;
                sumY2 += ret * ret;
              }

              const correlation = (n * sumXY - sumX * sumY) /
                (Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY)) || 1);

              if (correlation > bestCorrelation) {
                bestCorrelation = correlation;
                bestWeights = [w1, w2, w3, w4, w5];
              }
            }
          }
        }
      }

      // Convert correlation to accuracy % (0-100)
      const accuracy = Math.round(Math.max(0, Math.min(100, (bestCorrelation + 1) * 50)));

      return { weights: bestWeights, accuracy, tested, correlation: Math.round(bestCorrelation * 100) / 100 };
    };

    // ========== FACTOR INTERPRETATION (user-facing, no formula revealed) ==========
    const getFactorInterpretation = (name, value) => {
      const v = value;
      if (name === 'Fear/Greed Contrarian') {
        if (v >= 75) return { text: 'Le march√© est en panique ‚Äî historiquement, c\'est souvent une zone d\'accumulation pour les investisseurs patients.', signal: 'Fort' };
        if (v >= 55) return { text: 'Le sentiment est n√©gatif. Les corrections de ce type ont souvent pr√©c√©d√© des rebonds significatifs.', signal: 'Mod√©r√©' };
        if (v >= 40) return { text: 'Zone neutre ‚Äî le march√© n\'envoie pas de signal contrarian clair dans un sens ou l\'autre.', signal: 'Neutre' };
        if (v >= 25) return { text: 'L\'optimisme domine. La prudence est conseill√©e : les phases d\'euphorie peuvent pr√©c√©der des corrections.', signal: 'Faible' };
        return { text: 'Le march√© est en euphorie extr√™me. Historiquement, ces niveaux ont souvent marqu√© des sommets locaux.', signal: 'Tr√®s faible' };
      }
      if (name === 'BTC vs ATH') {
        if (v >= 90) return { text: 'Bitcoin est tr√®s proche de son record historique ‚Äî signe de force majeure du march√© et de confiance √©lev√©e.', signal: 'Fort' };
        if (v >= 70) return { text: 'Le march√© √©volue dans une zone haute. La tendance de fond reste haussi√®re avec un potentiel de continuation.', signal: 'Bon' };
        if (v >= 50) return { text: 'Bitcoin est √† mi-chemin de son ATH. Le march√© est en phase de construction ou de consolidation.', signal: 'Neutre' };
        if (v >= 30) return { text: 'Le march√© est significativement sous son ATH. Zone potentielle d\'accumulation pour le long terme.', signal: 'Opportunit√©' };
        return { text: 'Bitcoin est loin de son record. Le march√© traverse une phase de forte correction ‚Äî territoire de conviction.', signal: 'Contrarian' };
      }
      if (name === 'Market Breadth') {
        if (v >= 75) return { text: 'Large participation haussi√®re : la majorit√© des actifs progressent. Signe d\'un march√© sain et en tendance.', signal: 'Fort' };
        if (v >= 55) return { text: 'La majorit√© du march√© est en hausse. La tendance est positive mais quelques divergences apparaissent.', signal: 'Bon' };
        if (v >= 40) return { text: 'March√© partag√© : autant de gagnants que de perdants. Phase d\'ind√©cision ou de rotation sectorielle.', signal: 'Neutre' };
        if (v >= 20) return { text: 'Peu d\'actifs participent √† la hausse. La faiblesse est g√©n√©ralis√©e ‚Äî m√©fiance recommand√©e.', signal: 'Faible' };
        return { text: 'March√© en d√©tresse : quasi aucun actif ne progresse. Capitulation possible ou fin de cycle baissier.', signal: 'Alerte' };
      }
      if (name === 'Volatilit√©') {
        if (v >= 70) return { text: 'La volatilit√© est mod√©r√©e et constructive. Les mouvements sont ordonn√©s ‚Äî conditions id√©ales pour du trading directionnel.', signal: 'Optimal' };
        if (v >= 50) return { text: 'Volatilit√© dans une fourchette acceptable. Le march√© oscille normalement avec des opportunit√©s r√©guli√®res.', signal: 'Bon' };
        if (v >= 35) return { text: 'Tr√®s faible volatilit√©. Le march√© est en compression ‚Äî un mouvement explosif pourrait se pr√©parer dans un sens ou l\'autre.', signal: 'Attention' };
        return { text: 'Volatilit√© extr√™me. Les mouvements sont brutaux et impr√©visibles ‚Äî le risque est maximal, favoriser la r√©duction d\'exposition.', signal: 'Danger' };
      }
      if (name === 'Momentum 30j') {
        if (v >= 75) return { text: 'Fort momentum haussier sur 30 jours. La tendance est clairement √©tablie en faveur des acheteurs.', signal: 'Fort' };
        if (v >= 55) return { text: 'Momentum mod√©r√©ment positif. Le march√© est en l√©g√®re progression ‚Äî tendance favorable mais sans exc√®s.', signal: 'Bon' };
        if (v >= 40) return { text: 'Momentum neutre. Le march√© √©volue sans direction claire sur le mois √©coul√©. Phase d\'attente.', signal: 'Neutre' };
        if (v >= 20) return { text: 'Momentum n√©gatif. La tendance mensuelle est baissi√®re ‚Äî le march√© perd du terrain progressivement.', signal: 'Faible' };
        return { text: 'Fort momentum baissier. La pression vendeuse domine largement sur le mois ‚Äî phase de correction active.', signal: 'Tr√®s faible' };
      }
      // Mean Reversion
      if (v >= 70) return { text: 'Le march√© est fortement survendu par rapport √† sa moyenne. Les retours vers la moyenne favorisent un rebond.', signal: 'Fort' };
      if (v >= 50) return { text: 'L√©g√®rement en dessous de la moyenne. Conditions normales avec une l√©g√®re opportunit√© statistique.', signal: 'Bon' };
      if (v >= 35) return { text: 'Le march√© √©volue proche de sa moyenne. Pas de signal de d√©viation significatif.', signal: 'Neutre' };
      return { text: 'Le march√© est en surchauffe par rapport √† sa moyenne. Une correction vers la moyenne est statistiquement probable.', signal: 'Prudence' };
    };

    const getSignalColor = (signal) => {
      const map = { 'Fort': '#16c784', 'Bon': '#93d900', 'Optimal': '#16c784', 'Mod√©r√©': '#93d900', 'Neutre': '#c9b003', 'Attention': '#ea8c00', 'Opportunit√©': '#3b82f6', 'Contrarian': '#a855f7', 'Faible': '#ea8c00', 'Tr√®s faible': '#ea3943', 'Alerte': '#ea3943', 'Danger': '#ea3943', 'Prudence': '#ea8c00' };
      return map[signal] || '#c9b003';
    };

    // Compute Opportunity Index from real market data (with optimized weights)
    const computeOpportunityIndex = (fgValue, cryptos, btcPrice, btcAth, optWeights) => {
      const w = optWeights || [18, 24, 20, 16, 22];

      // Factor 1: Fear & Greed as contrarian
      const fgScore = fgValue <= 25 ? 85 : fgValue <= 40 ? 70 : fgValue <= 55 ? 50 : fgValue <= 75 ? 35 : 15;

      // Factor 2: BTC vs ATH (use estimated ATH or fallback to ratio-based score)
      const mcScore = btcAth > 0 ? Math.round(Math.min(100, (btcPrice / btcAth) * 100)) : 50;

      // Factor 3: Market breadth (use c24 as fallback when c7 unavailable)
      const bullCount = cryptos.filter(c => (c.c7 || c.c24 || 0) > 0).length;
      const breadthScore = Math.round((bullCount / Math.max(1, cryptos.length)) * 100);

      // Factor 4: Volatility signal
      const avgVol = cryptos.reduce((sum, c) => sum + Math.abs(c.c24 || 0), 0) / Math.max(1, cryptos.length);
      const volScore = avgVol < 1.5 ? 40 : avgVol < 3 ? 80 : avgVol < 6 ? 60 : 20;

      // Factor 5: Momentum (use c30 if available, else c24 scaled)
      const avg30d = cryptos.reduce((sum, c) => sum + (c.c30 || c.c24 || 0), 0) / Math.max(1, cryptos.length);
      const momScore = Math.max(0, Math.min(100, 50 + avg30d * 2));

      const indicators = [
        { name: 'Fear/Greed Contrarian', current: fgScore, weight: w[0] },
        { name: 'BTC vs ATH', current: mcScore, weight: w[1] },
        { name: 'Market Breadth', current: breadthScore, weight: w[2] },
        { name: 'Volatilit√©', current: volScore, weight: w[3] },
        { name: 'Momentum 30j', current: Math.round(momScore), weight: w[4] },
      ];

      const totalScore = Math.round(
        indicators.reduce((sum, ind) => sum + ind.current * (ind.weight / 100), 0)
      );

      return { score: Math.max(0, Math.min(100, totalScore)), indicators };
    };

    // ========== MINI COMPONENTS ==========
    const Badge = ({ children, color, glow }) => (
      <span className="inline-flex items-center gap-1.5 px-3 py-1 rounded-full text-xs font-semibold transition-all"
        style={{ backgroundColor: `${color}15`, color, border: `1px solid ${color}25`, boxShadow: glow ? `0 0 12px ${color}20` : 'none' }}>
        {children}
      </span>
    );

    const StatChip = ({ label, value, color }) => (
      <div className="px-4 py-2.5 rounded-xl text-center transition-all" style={{ backgroundColor: `${color}08`, border: `1px solid ${color}15` }}>
        <div className="text-[10px] font-bold tracking-widest uppercase" style={{ color }}>{label}</div>
        <div className="text-2xl font-black text-white mt-0.5 font-mono">{value}</div>
      </div>
    );

    const Loader = ({ text }) => (
      <div className="flex flex-col items-center justify-center py-20 gap-4">
        <div className="w-10 h-10 border-2 border-blue-500/30 border-t-blue-500 rounded-full animate-spin"></div>
        <p className="text-gray-400 text-sm font-medium">{text || 'Chargement des donn√©es...'}</p>
      </div>
    );

    const ErrorBanner = ({ message, onRetry }) => (
      <div className="glass rounded-xl p-4 mb-4 border-l-4 border-red-500 flex items-center justify-between">
        <div className="flex items-center gap-3">
          <span className="text-red-400 text-lg">‚ö†Ô∏è</span>
          <span className="text-sm text-gray-300">{message}</span>
        </div>
        {onRetry && <button onClick={onRetry} className="px-3 py-1.5 bg-blue-600/20 text-blue-400 rounded-lg text-xs font-bold hover:bg-blue-600/30 transition-all">R√©essayer</button>}
      </div>
    );

    const MiniSparkline = ({ data, width = 60, height = 24 }) => {
      if (!data || data.length < 2) return null;
      // Sample down to ~20 points for perf
      const step = Math.max(1, Math.floor(data.length / 20));
      const sampled = data.filter((_, i) => i % step === 0 || i === data.length - 1);
      const min = Math.min(...sampled);
      const max = Math.max(...sampled);
      const range = max - min || 1;
      const points = sampled.map((v, i) => {
        const x = (i / (sampled.length - 1)) * width;
        const y = height - ((v - min) / range) * (height - 2) - 1;
        return `${x},${y}`;
      }).join(' ');
      const lastVal = sampled[sampled.length - 1];
      const firstVal = sampled[0];
      const lineColor = lastVal >= firstVal ? '#16c784' : '#ea3943';
      return (
        <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`} className="overflow-visible">
          <defs>
            <linearGradient id={`sp-${Math.round(lastVal)}`} x1="0" y1="0" x2="0" y2="1">
              <stop offset="0%" stopColor={lineColor} stopOpacity="0.2" />
              <stop offset="100%" stopColor={lineColor} stopOpacity="0" />
            </linearGradient>
          </defs>
          <polygon points={`0,${height} ${points} ${width},${height}`} fill={`url(#sp-${Math.round(lastVal)})`} />
          <polyline points={points} fill="none" stroke={lineColor} strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" />
          <circle cx={width} cy={height - ((lastVal - min) / range) * (height - 2) - 1} r="2" fill={lineColor} />
        </svg>
      );
    };

    // ========== COMPONENTS ==========
    const FearGreedIndex = ({ value, history, btcHistory }) => {
      const [range, setRange] = useState('1y');
      if (!history || history.length === 0) return <div className="glass rounded-2xl p-6"><Loader text="Chargement Fear & Greed Index..." /></div>;

      const c = getFearGreedClass(value);
      const yesterday = history[history.length - 2]?.value || 0;
      const lastWeek = history[history.length - 8]?.value || 0;
      const lastMonth = history[history.length - 31]?.value || 0;
      const yearData = history.slice(-365);
      const yHigh = Math.max(...yearData.map(d => d.value));
      const yLow = Math.min(...yearData.map(d => d.value));
      const filtered = range === '30d' ? history.slice(-30) : range === '1y' ? history.slice(-365) : history;

      // Align BTC history with FG history by date
      const filteredBtc = range === '30d' ? (btcHistory || []).slice(-30) : range === '1y' ? (btcHistory || []).slice(-365) : (btcHistory || []);
      const btcMin = filteredBtc.length > 0 ? Math.min(...filteredBtc.map(b => b.price)) : 0;
      const btcMax = filteredBtc.length > 0 ? Math.max(...filteredBtc.map(b => b.price)) : 1;

      const needleAngle = -90 + (value / 100) * 180;

      // Dynamic date labels
      const getDateLabels = () => {
        if (filtered.length === 0) return [];
        const first = new Date(filtered[0].ts * 1000);
        const last = new Date(filtered[filtered.length - 1].ts * 1000);
        const fmt = (d) => d.toLocaleDateString('fr-FR', { month: 'short', year: '2-digit' });
        if (range === '30d') return [fmt(first), fmt(new Date((first.getTime() + last.getTime()) / 2)), 'Auj.'];
        const step = Math.floor(filtered.length / 4);
        return [0, step, step*2, step*3, filtered.length-1].map(i => filtered[i] ? fmt(new Date(filtered[i].ts * 1000)) : '');
      };

      return (
        <div className="glass rounded-2xl overflow-hidden animate-fadeInUp">
          <div className="grid grid-cols-1 lg:grid-cols-3">
            <div className="p-6 lg:p-8 border-b lg:border-b-0 lg:border-r border-white/5">
              <div className="flex items-center gap-2 mb-1">
                <div className="w-2 h-2 rounded-full" style={{ backgroundColor: c.color, boxShadow: `0 0 8px ${c.color}` }} />
                <h3 className="text-base font-bold text-white tracking-tight">Fear & Greed Index</h3>
              </div>
              <p className="text-[11px] text-gray-500 mb-6 ml-4">Source: Alternative.me (donn√©es r√©elles)</p>

              <div className="flex justify-center mb-6">
                <svg width="220" height="135" viewBox="0 0 220 135">
                  <defs>
                    <linearGradient id="fgArc" x1="0%" y1="0%" x2="100%" y2="0%">
                      <stop offset="0%" stopColor="#ea3943"/><stop offset="25%" stopColor="#ea8c00"/>
                      <stop offset="50%" stopColor="#c9b003"/><stop offset="75%" stopColor="#93d900"/>
                      <stop offset="100%" stopColor="#16c784"/>
                    </linearGradient>
                    <filter id="fgGlow"><feGaussianBlur stdDeviation="3" result="blur"/><feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
                  </defs>
                  <path d="M 20 110 A 90 90 0 0 1 200 110" fill="none" stroke="rgba(30,58,95,0.4)" strokeWidth="14" strokeLinecap="round"/>
                  <path d="M 20 110 A 90 90 0 0 1 200 110" fill="none" stroke="url(#fgArc)" strokeWidth="14" strokeLinecap="round" filter="url(#fgGlow)"/>
                  {[0, 25, 50, 75, 100].map(tick => {
                    const angle = (-180 + (tick / 100) * 180) * Math.PI / 180;
                    return <line key={tick} x1={110 + Math.cos(angle) * 78} y1={110 + Math.sin(angle) * 78} x2={110 + Math.cos(angle) * 70} y2={110 + Math.sin(angle) * 70} stroke="rgba(255,255,255,0.2)" strokeWidth="1.5"/>;
                  })}
                  <g style={{ transform: `rotate(${needleAngle}deg)`, transformOrigin: '110px 110px', transition: 'transform 1.2s cubic-bezier(0.34, 1.56, 0.64, 1)' }}>
                    <line x1="110" y1="110" x2="110" y2="32" stroke={c.color} strokeWidth="2.5" strokeLinecap="round" style={{ filter: `drop-shadow(0 0 6px ${c.color})` }}/>
                    <circle cx="110" cy="110" r="8" fill={c.color} style={{ filter: `drop-shadow(0 0 8px ${c.color})` }}/>
                    <circle cx="110" cy="110" r="4" fill="#0f2744"/>
                  </g>
                  <text x="110" y="96" textAnchor="middle" fill={c.color} fontSize="38" fontWeight="800" fontFamily="'JetBrains Mono', monospace" style={{ filter: `drop-shadow(0 0 10px ${c.color}40)` }}>{value}</text>
                </svg>
              </div>

              <div className="text-center mb-6">
                <div className="flex items-center justify-center gap-2.5 mb-2">
                  <span className="text-3xl animate-float">{c.emoji}</span>
                  <span className="text-xl font-extrabold tracking-tight" style={{ color: c.color }}>{c.label}</span>
                </div>
                <p className="text-xs text-gray-400 font-medium">{c.desc}</p>
              </div>

              <div className="space-y-2.5 mb-5">
                <h4 className="text-xs font-bold text-gray-400 uppercase tracking-wider">Historique</h4>
                {[{l:'Hier', v:yesterday}, {l:'Semaine', v:lastWeek}, {l:'Mois', v:lastMonth}].map((x, i) => {
                  const cl = getFearGreedClass(x.v);
                  return (
                    <div key={i} className="flex items-center justify-between py-1">
                      <span className="text-sm text-gray-500">{x.l}</span>
                      <Badge color={cl.color}>{cl.label} - {x.v}</Badge>
                    </div>
                  );
                })}
              </div>

              <div className="space-y-2.5 pt-4 border-t border-white/5">
                <h4 className="text-xs font-bold text-gray-400 uppercase tracking-wider">Annuel</h4>
                <div className="flex items-center justify-between py-1">
                  <span className="text-xs text-gray-500 flex items-center gap-1.5"><span className="text-emerald-400">‚ñ≤</span> High</span>
                  <Badge color={getFearGreedClass(yHigh).color} glow>{getFearGreedClass(yHigh).label} - {yHigh}</Badge>
                </div>
                <div className="flex items-center justify-between py-1">
                  <span className="text-xs text-gray-500 flex items-center gap-1.5"><span className="text-red-400">‚ñº</span> Low</span>
                  <Badge color={getFearGreedClass(yLow).color}>{getFearGreedClass(yLow).label} - {yLow}</Badge>
                </div>
              </div>
            </div>

            <div className="lg:col-span-2 p-6 lg:p-8">
              <div className="flex items-center justify-between mb-5">
                <div>
                  <h3 className="text-base font-bold text-white tracking-tight">Graphique Fear & Greed</h3>
                  <div className="flex items-center gap-5 mt-2 text-xs">
                    <div className="flex items-center gap-2"><span className="w-5 h-0.5 rounded-full bg-orange-500"/><span className="text-gray-500">Fear & Greed</span></div>
                    <div className="flex items-center gap-2"><span className="w-5 h-0.5 rounded-full bg-gray-500"/><span className="text-gray-500">BTC Price</span></div>
                  </div>
                </div>
                <div className="flex gap-1 glass-light rounded-xl p-1">
                  {['30d','1y','All'].map(r => (
                    <button key={r} onClick={() => setRange(r)}
                      className={`px-3.5 py-1.5 rounded-lg text-xs font-bold transition-all ${range===r ? 'bg-blue-600/80 text-white shadow-lg shadow-blue-600/20' : 'text-gray-500 hover:text-gray-300'}`}>{r}</button>
                  ))}
                </div>
              </div>

              <div className="relative h-72 bg-dark-900/80 rounded-xl overflow-hidden border border-white/5">
                <div className="absolute inset-0 flex flex-col">
                  {[{c:'#16c784'},{c:'#93d900'},{c:'#c9b003'},{c:'#ea8c00'},{c:'#ea3943'}].map((z, i) => (
                    <div key={i} className="flex-1" style={{ background: `linear-gradient(180deg, ${z.c}06 0%, ${z.c}02 100%)`, borderBottom: i < 4 ? `1px solid ${z.c}12` : 'none' }} />
                  ))}
                </div>
                <div className="absolute right-2.5 top-0 bottom-0 flex flex-col justify-between py-3 text-[9px] font-mono font-medium z-10">
                  <span className="text-gray-600">100</span>
                  <span className="text-[#16c784]/60">Extreme Greed</span>
                  <span className="text-[#93d900]/60">Greed</span>
                  <span className="text-[#c9b003]/60">Neutral</span>
                  <span className="text-[#ea8c00]/60">Fear</span>
                  <span className="text-[#ea3943]/60">Extreme Fear</span>
                  <span className="text-gray-600">0</span>
                </div>
                <svg className="absolute inset-0 w-full h-full" preserveAspectRatio="none" viewBox="0 0 100 100">
                  {[20,40,55,74].map(y => <line key={y} x1="0" y1={100-y} x2="92" y2={100-y} stroke="rgba(255,255,255,0.03)" strokeWidth="0.2"/>)}
                  {filteredBtc.length > 1 && (
                    <path d={filteredBtc.map((p,i) => {
                      const x = (i/(filteredBtc.length-1))*92;
                      const y = 100-((p.price-btcMin)/(btcMax-btcMin))*90 - 5;
                      return `${i===0?'M':'L'} ${x},${Math.max(0,Math.min(100,y))}`;
                    }).join(' ')} fill="none" stroke="rgba(156,163,175,0.25)" strokeWidth="0.3"/>
                  )}
                  <defs>
                    <linearGradient id="fgFill" x1="0" y1="0" x2="0" y2="1">
                      <stop offset="0%" stopColor={c.color} stopOpacity="0.15"/>
                      <stop offset="100%" stopColor={c.color} stopOpacity="0"/>
                    </linearGradient>
                  </defs>
                  {filtered.length > 1 && (
                    <path d={`M 0,100 ${filtered.map((p,i) => `L ${(i/(filtered.length-1))*92},${100-p.value}`).join(' ')} L ${92},100 Z`} fill="url(#fgFill)"/>
                  )}
                  {filtered.map((p,i) => {
                    if(i===0) return null;
                    const pr = filtered[i-1];
                    return <line key={i} x1={((i-1)/(filtered.length-1))*92} y1={100-pr.value} x2={(i/(filtered.length-1))*92} y2={100-p.value} stroke={getFearGreedClass((p.value+pr.value)/2).color} strokeWidth="0.5"/>;
                  })}
                </svg>
                <div className="absolute right-16 px-2.5 py-1 rounded-lg text-xs font-black z-20 font-mono"
                  style={{ top: `${100-value}%`, backgroundColor: c.color, color: '#000', transform: 'translateY(-50%)', boxShadow: `0 0 16px ${c.color}50` }}>{value}</div>
              </div>

              <div className="flex justify-between mt-3 text-[10px] text-gray-600 font-mono pr-16">
                {getDateLabels().map((lbl, i) => <span key={i}>{lbl}</span>)}
              </div>

              <div className="mt-5 p-3.5 glass-light rounded-xl">
                <p className="text-xs text-gray-400 leading-relaxed">
                  <strong className="text-gray-300">Tip :</strong> "Be fearful when others are greedy, and greedy when others are fearful." ‚Äî Warren Buffett
                </p>
              </div>
            </div>
          </div>
        </div>
      );
    };

    const OpportunityIndex = ({ score, indicators, showDetails, setShowDetails, prevScore, optResult }) => {
      const [anim, setAnim] = useState(0);
      const [expandedFactor, setExpandedFactor] = useState(null);
      useEffect(() => { setTimeout(() => setAnim(score), 100); }, [score]);
      const c = getOppClass(anim);
      const change = score - (prevScore || score);
      const needleAngle = -90 + (anim / 100) * 180;
      const factorColors = ['#3b82f6', '#22c55e', '#eab308', '#f97316', '#a855f7'];

      return (
        <div className="glass rounded-2xl p-6 lg:p-8 animate-fadeInUp" style={{ animationDelay: '0.1s' }}>
          <div className="flex items-center justify-between mb-6">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-xl flex items-center justify-center text-xl" style={{ backgroundColor: `${c.color}15`, border: `1px solid ${c.color}25` }}>üéØ</div>
              <div>
                <h2 className="text-lg font-extrabold text-white tracking-tight">Indice d'Opportunit√©</h2>
                <div className="flex items-center gap-2 mt-0.5">
                  <p className="text-[11px] text-gray-500">Poids optimis√©s par backtest sur 2 ans</p>
                  {optResult && optResult.accuracy > 0 && (
                    <span className="text-[9px] font-mono font-bold px-1.5 py-0.5 rounded-full bg-emerald-500/10 text-emerald-400 border border-emerald-500/20">
                      {optResult.tested.toLocaleString()} combinaisons test√©es ‚Ä¢ r={optResult.correlation}
                    </span>
                  )}
                </div>
              </div>
            </div>
            <button onClick={() => setShowDetails(!showDetails)}
              className="px-4 py-2 glass-light rounded-xl text-sm font-bold transition-all hover:bg-blue-600/20 text-blue-400 flex items-center gap-2">
              {showDetails ? 'MASQUER' : 'GUIDE'}
              <svg className={`w-4 h-4 transition-transform ${showDetails ? 'rotate-180' : ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" /></svg>
            </button>
          </div>

          <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <div className="flex flex-col items-center">
              <svg width="280" height="165" viewBox="0 0 280 165">
                <defs>
                  <linearGradient id="oppG" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" stopColor="#ea3943"/><stop offset="25%" stopColor="#ea8c00"/>
                    <stop offset="50%" stopColor="#c9b003"/><stop offset="75%" stopColor="#93d900"/>
                    <stop offset="100%" stopColor="#16c784"/>
                  </linearGradient>
                  <filter id="oppGlow"><feGaussianBlur stdDeviation="4" result="blur"/><feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
                </defs>
                <path d="M 25 140 A 115 115 0 0 1 255 140" fill="none" stroke="rgba(30,58,95,0.3)" strokeWidth="16" strokeLinecap="round"/>
                <path d="M 25 140 A 115 115 0 0 1 255 140" fill="none" stroke="url(#oppG)" strokeWidth="16" strokeLinecap="round" filter="url(#oppGlow)"/>
                {[0,20,40,60,80,100].map(tick => {
                  const angle = (-180 + (tick/100)*180) * Math.PI / 180;
                  return <line key={tick} x1={140+Math.cos(angle)*103} y1={140+Math.sin(angle)*103} x2={140+Math.cos(angle)*95} y2={140+Math.sin(angle)*95} stroke="rgba(255,255,255,0.15)" strokeWidth="1.5"/>;
                })}
                <g style={{ transform: `rotate(${needleAngle}deg)`, transformOrigin: '140px 140px', transition: 'transform 1.5s cubic-bezier(0.34, 1.56, 0.64, 1)' }}>
                  <polygon points="140,38 136,140 144,140" fill={c.color} style={{ filter: `drop-shadow(0 0 8px ${c.color})` }}/>
                  <circle cx="140" cy="140" r="10" fill={c.color} style={{ filter: `drop-shadow(0 0 10px ${c.color})` }}/>
                  <circle cx="140" cy="140" r="5" fill="#0f2744"/>
                </g>
                <text x="140" y="122" textAnchor="middle" fill={c.color} fontSize="44" fontWeight="800" fontFamily="'JetBrains Mono', monospace" style={{ filter: `drop-shadow(0 0 12px ${c.color}40)` }}>{Math.round(anim)}</text>
                <text x="22" y="158" fill="#ea3943" fontSize="10" fontWeight="700" fontFamily="'JetBrains Mono', monospace" opacity="0.6">0</text>
                <text x="248" y="158" fill="#16c784" fontSize="10" fontWeight="700" fontFamily="'JetBrains Mono', monospace" opacity="0.6">100</text>
              </svg>
              <div className="text-center mt-3">
                <div className="flex items-center justify-center gap-2.5">
                  <span className="text-3xl animate-float">{c.emoji}</span>
                  <span className="text-2xl font-extrabold tracking-tight" style={{ color: c.color }}>{c.label}</span>
                </div>
                <p className="text-sm text-gray-400 mt-1 font-medium">{c.desc}</p>
              </div>
            </div>

            <div>
              <h3 className="text-xs font-bold text-gray-400 uppercase tracking-wider mb-4">D√©composition des facteurs</h3>
              <div className="space-y-2">
                {indicators.map((ind, i) => {
                  const fc = factorColors[i] || '#3b82f6';
                  const interp = getFactorInterpretation(ind.name, ind.current);
                  const isExpanded = expandedFactor === i;
                  return (
                    <div key={i} className="glass-light rounded-xl p-3.5 transition-all hover:border-white/10 cursor-pointer"
                      style={{ borderLeft: `3px solid ${fc}` }}
                      onClick={(e) => { e.stopPropagation(); setExpandedFactor(isExpanded ? null : i); }}>
                      <div className="flex items-center justify-between mb-2">
                        <div className="flex items-center gap-2">
                          <span className="text-sm font-bold text-white">{ind.name}</span>
                          <span className="text-[10px] font-mono px-1.5 py-0.5 rounded" style={{ backgroundColor: `${fc}15`, color: fc }}>{ind.weight}%</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <span className="text-[10px] font-bold px-1.5 py-0.5 rounded-full" style={{ backgroundColor: `${getSignalColor(interp.signal)}15`, color: getSignalColor(interp.signal) }}>{interp.signal}</span>
                          <span className="text-sm font-black font-mono" style={{ color: fc }}>{ind.current}</span>
                        </div>
                      </div>
                      <div className="relative h-2 bg-dark-900/60 rounded-full overflow-hidden progress-bar">
                        <div className="absolute h-full rounded-full transition-all duration-1000 ease-out" style={{ width: `${ind.current}%`, background: `linear-gradient(90deg, ${fc}80, ${fc})` }}/>
                      </div>
                      {isExpanded && (
                        <div className="mt-3 pt-2.5 border-t border-white/5 animate-fadeInUp">
                          <p className="text-[11px] text-gray-400 leading-relaxed">{interp.text}</p>
                        </div>
                      )}
                      {!isExpanded && (
                        <div className="mt-1 text-[9px] text-gray-600 text-right">cliquer pour lire l'analyse</div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
          </div>

          {showDetails && (
            <div className="mt-8 pt-6 border-t border-white/5 animate-fadeInUp">
              <h3 className="text-base font-extrabold text-white mb-2 flex items-center gap-2">
                <span className="text-lg">üìñ</span> Guide d'interpr√©tation
              </h3>
              <p className="text-xs text-gray-500 mb-5">Comment lire chaque facteur ‚Äî cliquez sur un facteur ci-dessus pour l'analyse d√©taill√©e en temps r√©el.</p>
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {[
                  {n:'Fear/Greed Contrarian', c:'#3b82f6', ranges:[
                    {r:'75-100', l:'Zone d\'opportunit√© contrarian forte', cl:'#16c784'},
                    {r:'50-74', l:'Signal mod√©r√© ‚Äî le march√© est craintif', cl:'#93d900'},
                    {r:'25-49', l:'Zone neutre ‚Äî pas de signal clair', cl:'#c9b003'},
                    {r:'0-24', l:'March√© euphorique ‚Äî prudence recommand√©e', cl:'#ea3943'},
                  ]},
                  {n:'BTC vs ATH', c:'#22c55e', ranges:[
                    {r:'80-100', l:'Proche du record ‚Äî march√© en force', cl:'#16c784'},
                    {r:'60-79', l:'Zone haute ‚Äî tendance haussi√®re confirm√©e', cl:'#93d900'},
                    {r:'40-59', l:'Mi-parcours ‚Äî phase de consolidation', cl:'#c9b003'},
                    {r:'0-39', l:'Loin du ATH ‚Äî zone d\'accumulation potentielle', cl:'#ea8c00'},
                  ]},
                  {n:'Market Breadth', c:'#eab308', ranges:[
                    {r:'70-100', l:'Large participation ‚Äî march√© sain', cl:'#16c784'},
                    {r:'50-69', l:'Majorit√© en hausse ‚Äî plut√¥t positif', cl:'#93d900'},
                    {r:'30-49', l:'March√© divis√© ‚Äî rotation en cours', cl:'#c9b003'},
                    {r:'0-29', l:'Faible participation ‚Äî m√©fiance', cl:'#ea3943'},
                  ]},
                  {n:'Volatilit√©', c:'#f97316', ranges:[
                    {r:'70-100', l:'Volatilit√© mod√©r√©e ‚Äî conditions id√©ales', cl:'#16c784'},
                    {r:'50-69', l:'Fourchette normale ‚Äî acceptable', cl:'#93d900'},
                    {r:'30-49', l:'Tr√®s faible ‚Äî compression, mouvement √† venir', cl:'#c9b003'},
                    {r:'0-29', l:'Extr√™me ‚Äî risque maximal', cl:'#ea3943'},
                  ]},
                  {n:'Momentum 30j', c:'#a855f7', ranges:[
                    {r:'70-100', l:'Fort momentum haussier √©tabli', cl:'#16c784'},
                    {r:'50-69', l:'Tendance l√©g√®rement positive', cl:'#93d900'},
                    {r:'30-49', l:'Neutre √† baissier ‚Äî attente', cl:'#c9b003'},
                    {r:'0-29', l:'Momentum baissier ‚Äî correction active', cl:'#ea3943'},
                  ]},
                ].map((f, i) => (
                  <div key={i} className="glass-light rounded-xl p-5 transition-all hover:border-white/10" style={{ borderLeft: `3px solid ${f.c}` }}>
                    <div className="flex items-center gap-2 mb-3">
                      <span className="font-bold text-white text-sm">{f.n}</span>
                    </div>
                    <div className="space-y-2">
                      {f.ranges.map((r, j) => (
                        <div key={j} className="flex items-start gap-2">
                          <span className="text-[10px] font-mono font-bold w-12 flex-shrink-0 text-right" style={{ color: r.cl }}>{r.r}</span>
                          <span className="text-[11px] text-gray-400">{r.l}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      );
    };

    const CryptoCard = ({ crypto: cr, rank, index }) => {
      const [exp, setExp] = useState(false);
      const sent = computeSentiment(cr);
      const st = getSentimentStyle(sent);
      const flow = computeFlow(cr);

      return (
        <div className="glass rounded-xl p-4 card-hover cursor-pointer animate-fadeInUp"
          style={{ animationDelay: `${Math.min(index * 0.02, 0.4)}s` }}
          onClick={() => setExp(!exp)}>
          <div className="flex items-center justify-between mb-3">
            <div className="flex items-center gap-2.5">
              <span className="text-[10px] font-mono font-bold text-gray-600 w-5 text-right">#{rank}</span>
              {cr.image ? <img src={cr.image} alt={cr.sym} className="w-7 h-7 rounded-full" /> :
                <div className="w-7 h-7 rounded-full bg-gray-700 flex items-center justify-center text-xs font-bold">{cr.sym.charAt(0)}</div>
              }
              <div>
                <div className="font-bold text-white text-sm tracking-tight">{cr.sym}</div>
                <div className="text-[10px] text-gray-500 font-medium truncate max-w-[80px]">{cr.name}</div>
              </div>
            </div>
            <div className="text-right">
              <div className="text-white text-sm font-bold font-mono">
                ${cr.price < 0.01 ? cr.price.toFixed(6) : cr.price < 1 ? cr.price.toFixed(4) : cr.price < 1000 ? cr.price.toFixed(2) : cr.price.toLocaleString('en-US', {maximumFractionDigits: 0})}
              </div>
              <div className={`text-xs font-bold font-mono ${cr.c24 >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                {cr.c24 >= 0 ? '+' : ''}{(cr.c24 || 0).toFixed(2)}%
              </div>
            </div>
          </div>

          <div className="mb-3">
            <div className="flex items-center justify-between text-xs mb-1.5">
              <span className="text-gray-500 font-medium">Sentiment</span>
              <div className="flex items-center gap-2">
                <MiniSparkline data={cr.sparkline} />
                <span className="font-bold font-mono" style={{ color: st.color }}>{sent}</span>
              </div>
            </div>
            <div className="relative h-1.5 bg-dark-900/60 rounded-full overflow-hidden">
              <div className="absolute h-full rounded-full transition-all duration-700" style={{ width: `${sent}%`, background: `linear-gradient(90deg, ${st.color}60, ${st.color})` }}/>
            </div>
            <div className="flex justify-between items-center mt-1.5">
              <Badge color={st.color}>{st.label}</Badge>
              <span className="text-[10px] text-gray-500 font-mono">ATH: {(cr.athChange || 0).toFixed(0)}%</span>
            </div>
          </div>

          <div className="flex items-center justify-between text-xs px-3 py-2 glass-light rounded-lg">
            <span className="text-gray-500 font-medium">Trend 7j</span>
            <span className={`font-bold font-mono ${flow >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
              {flow >= 0 ? '‚Üë Hausse' : '‚Üì Baisse'} <span className="text-gray-500">({flow > 0 ? '+' : ''}{flow}%)</span>
            </span>
          </div>

          {exp && (
            <div className="mt-3 pt-3 border-t border-white/5 space-y-3 animate-fadeInUp">
              <div className="grid grid-cols-4 gap-2 text-center">
                {[{l:'1H',v:cr.c1h},{l:'24H',v:cr.c24},{l:'7J',v:cr.c7},{l:'30J',v:cr.c30}].map((x, i) => (
                  <div key={i} className="glass-light rounded-lg p-2">
                    <div className="text-[9px] text-gray-500 font-bold uppercase">{x.l}</div>
                    <div className={`text-xs font-black font-mono ${(x.v||0) >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                      {(x.v||0) >= 0 ? '+' : ''}{(x.v||0).toFixed(1)}%
                    </div>
                  </div>
                ))}
              </div>
              <div className="grid grid-cols-2 gap-2 text-xs">
                <div className="glass-light rounded-lg p-2">
                  <div className="text-[9px] text-gray-500 font-bold uppercase">Market Cap</div>
                  <div className="text-white font-bold font-mono">${cr.marketCap > 1e9 ? (cr.marketCap/1e9).toFixed(1)+'B' : (cr.marketCap/1e6).toFixed(0)+'M'}</div>
                </div>
                <div className="glass-light rounded-lg p-2">
                  <div className="text-[9px] text-gray-500 font-bold uppercase">Volume 24h</div>
                  <div className="text-white font-bold font-mono">${cr.volume24h > 1e9 ? (cr.volume24h/1e9).toFixed(1)+'B' : (cr.volume24h/1e6).toFixed(0)+'M'}</div>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    };

    const Header = ({ isLive, time, stats, lastUpdate }) => (
      <header className="mb-8 animate-fadeInUp">
        <div className="flex flex-col lg:flex-row items-start lg:items-center justify-between gap-5">
          <div>
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-xl bg-gradient-to-br from-blue-600 to-cyan-500 flex items-center justify-center text-lg font-black text-white shadow-lg shadow-blue-600/20">CS</div>
              <div>
                <h1 className="text-2xl font-black tracking-tight text-gradient">CRYPTO SENTINEL PRO</h1>
                <div className="flex items-center gap-3 mt-1">
                  <span className={`flex items-center gap-2 px-2.5 py-1 rounded-full text-[10px] font-bold uppercase tracking-wider ${isLive ? 'bg-emerald-500/10 text-emerald-400 border border-emerald-500/20' : 'bg-yellow-500/10 text-yellow-400 border border-yellow-500/20'}`}>
                    <span className={`w-1.5 h-1.5 rounded-full ${isLive ? 'bg-emerald-400 animate-pulse' : 'bg-yellow-400'}`} style={isLive ? { boxShadow: '0 0 6px #22c55e' } : {}}/>
                    {isLive ? 'LIVE' : 'CHARGEMENT...'}
                  </span>
                  <span className="text-xs text-gray-500 font-mono">{time}</span>
                  {lastUpdate && <span className="text-[10px] text-gray-600">MAJ: {lastUpdate}</span>}
                </div>
              </div>
            </div>
          </div>
          <div className="flex gap-2">
            <StatChip label="Bull" value={stats.bull} color="#22c55e" />
            <StatChip label="Neut" value={stats.neut} color="#eab308" />
            <StatChip label="Bear" value={stats.bear} color="#ef4444" />
          </div>
        </div>
      </header>
    );

    const Filters = ({ filter, setFilter, search, setSearch, sort, setSort }) => (
      <div className="flex flex-col lg:flex-row items-stretch lg:items-center justify-between gap-4 mb-5 p-4 glass rounded-xl animate-fadeInUp" style={{ animationDelay: '0.2s' }}>
        <div className="relative w-full lg:w-72">
          <span className="absolute left-3.5 top-1/2 -translate-y-1/2 text-gray-500 text-sm">
            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
          </span>
          <input type="text" placeholder="Rechercher un token..." value={search} onChange={e => setSearch(e.target.value)}
            className="w-full bg-dark-900/60 border border-white/5 rounded-xl pl-10 pr-4 py-2.5 text-white text-sm placeholder-gray-600 focus:outline-none focus:border-blue-500/50 focus:ring-1 focus:ring-blue-500/20 transition-all font-medium"/>
        </div>
        <div className="flex flex-wrap items-center gap-2">
          {[{k:'ALL',l:'Tous'},{k:'BULLISH',l:'Bullish'},{k:'NEUTRAL',l:'Neutre'},{k:'BEARISH',l:'Bearish'}].map(f => (
            <button key={f.k} onClick={() => setFilter(f.k)}
              className={`px-4 py-2 rounded-xl text-xs font-bold transition-all ${filter===f.k ? 'bg-blue-600/80 text-white shadow-lg shadow-blue-600/15' : 'glass-light text-gray-500 hover:text-gray-300'}`}>{f.l}</button>
          ))}
          <select value={sort} onChange={e => setSort(e.target.value)}
            className="px-3 py-2 bg-dark-900/60 border border-white/5 rounded-xl text-white text-xs font-bold focus:outline-none focus:border-blue-500/50 cursor-pointer">
            <option value="rank">Par rang</option>
            <option value="sentiment">Sentiment ‚Üì</option>
            <option value="change24h">24h ‚Üì</option>
            <option value="volume">Volume ‚Üì</option>
          </select>
        </div>
      </div>
    );

    // ========== DISCLAIMER POPUP ==========
    const Disclaimer = ({ onAccept }) => (
      <div className="fixed inset-0 z-50 flex items-center justify-center p-4" style={{ backgroundColor: 'rgba(0,0,0,0.85)', backdropFilter: 'blur(8px)' }}>
        <div className="glass rounded-2xl max-w-lg w-full p-8 animate-fadeInUp shadow-2xl" style={{ border: '1px solid rgba(59,130,246,0.2)' }}>
          <div className="flex items-center gap-3 mb-5">
            <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-amber-500 to-orange-600 flex items-center justify-center text-2xl shadow-lg">‚ö†Ô∏è</div>
            <div>
              <h2 className="text-xl font-extrabold text-white tracking-tight">Avertissement</h2>
              <p className="text-xs text-gray-500 font-medium">Veuillez lire attentivement avant de continuer</p>
            </div>
          </div>

          <div className="space-y-4 mb-6 text-sm text-gray-300 leading-relaxed">
            <p><strong className="text-amber-400">Ce site ne constitue en aucun cas un conseil en investissement.</strong> Les informations pr√©sent√©es sur Crypto Sentinel Pro sont fournies √† titre purement informatif et √©ducatif.</p>
            <p>Les donn√©es affich√©es (indices de sentiment, scores d'opportunit√©, classements) sont g√©n√©r√©es √† partir d'algorithmes propri√©taires bas√©s sur des donn√©es de march√© publiques. <strong className="text-white">Aucune garantie de pr√©cision, d'exhaustivit√© ou de fiabilit√©</strong> n'est offerte.</p>
            <p>Le march√© des cryptomonnaies est <strong className="text-red-400">extr√™mement volatil et risqu√©</strong>. Vous pouvez perdre la totalit√© de votre investissement. Ne prenez jamais de d√©cision financi√®re bas√©e uniquement sur les informations de ce site.</p>
            <p className="text-xs text-gray-500">En poursuivant, vous reconnaissez avoir lu et compris cet avertissement et acceptez que les cr√©ateurs de Crypto Sentinel Pro ne peuvent √™tre tenus responsables de toute perte financi√®re.</p>
          </div>

          <button onClick={onAccept}
            className="w-full py-3.5 rounded-xl font-extrabold text-sm tracking-wide transition-all hover:brightness-110 active:scale-[0.98]"
            style={{ background: 'linear-gradient(135deg, #3b82f6, #06b6d4)', color: 'white', boxShadow: '0 4px 24px rgba(59,130,246,0.3)' }}>
            J'AI LU ET J'ACCEPTE LES CONDITIONS
          </button>

          <p className="text-center text-[10px] text-gray-600 mt-3">Ce message s'affiche √† chaque visite pour votre protection.</p>
        </div>
      </div>
    );

    // ========== MAIN APP ==========
    function App() {
      const [time, setTime] = useState(new Date().toLocaleTimeString('fr-FR'));
      const [cryptos, setCryptos] = useState([]);
      const [fgHist, setFgHist] = useState([]);
      const [btcHist, setBtcHist] = useState([]);
      const [filter, setFilter] = useState('ALL');
      const [search, setSearch] = useState('');
      const [sort, setSort] = useState('rank');
      const [showDet, setShowDet] = useState(false);
      const [loading, setLoading] = useState(true);
      const [errors, setErrors] = useState([]);
      const [lastUpdate, setLastUpdate] = useState(null);
      const [prevOppScore, setPrevOppScore] = useState(null);
      const [optResult, setOptResult] = useState(null);
      const [disclaimerAccepted, setDisclaimerAccepted] = useState(false);

      const fgVal = fgHist.length > 0 ? fgHist[fgHist.length - 1].value : 0;
      const btcCoin = cryptos.find(c => c.sym === 'BTC');
      const btcPrice = btcCoin?.price || 0;
      const btcAth = btcCoin?.ath || 0;
      const optWeights = optResult?.weights || null;
      const oppData = cryptos.length > 0 ? computeOpportunityIndex(fgVal, cryptos, btcPrice, btcAth, optWeights) : { score: 0, indicators: [] };

      const stats = useMemo(() => {
        return {
          bull: cryptos.filter(c => computeSentiment(c) > 60).length,
          neut: cryptos.filter(c => { const s = computeSentiment(c); return s >= 40 && s <= 60; }).length,
          bear: cryptos.filter(c => computeSentiment(c) < 40).length,
        };
      }, [cryptos]);

      // Load cached data immediately on mount
      useEffect(() => {
        const cachedFg = loadCache('fg');
        const cachedBtc = loadCache('btc');
        const cachedCryptos = loadCache('cryptos');
        if (cachedFg) setFgHist(cachedFg);
        if (cachedBtc) setBtcHist(cachedBtc);
        if (cachedCryptos) setCryptos(cachedCryptos);
        if (cachedFg || cachedCryptos) {
          setLoading(false);
          setLastUpdate('cache');
        }
      }, []);

      // Fetch all data ‚Äî CoinCap API (200 req/min, no key needed)
      const loadAllData = useCallback(async (isFirstLoad = false) => {
        const newErrors = [];

        // Fetch all 3 APIs in parallel (CoinCap is generous with rate limits)
        const [fgData, cryptoData, btcData] = await Promise.all([
          fetchWithRetry(fetchFearGreedData),
          fetchWithRetry(fetchCryptos),
          fetchWithRetry(fetchBtcHistory),
        ]);

        if (fgData) {
          setFgHist(fgData);
        } else if (!loadCache('fg')) {
          newErrors.push('Fear & Greed Index indisponible');
        }

        let finalCryptos = cryptoData;
        if (cryptoData) {
          setCryptos(cryptoData);
          // Enrich top 20 with 7d/30d data (background, non-blocking)
          if (isFirstLoad) {
            enrichCryptosWithHistory(cryptoData).then(enriched => {
              if (enriched) setCryptos(enriched);
            });
          }
        } else if (!loadCache('cryptos')) {
          newErrors.push('Donn√©es march√© indisponibles');
        }

        if (btcData) {
          setBtcHist(btcData);
        } else if (!loadCache('btc')) {
          newErrors.push('Historique BTC indisponible');
        }

        setErrors(newErrors);
        setLoading(false);
        setLastUpdate(new Date().toLocaleTimeString('fr-FR'));

        // Run backtest optimization
        const finalFg = fgData || loadCache('fg');
        const finalBtc = btcData || loadCache('btc');
        if (finalFg && finalBtc) {
          const opt = runBacktestOptimization(finalFg, finalBtc);
          setOptResult(opt);
        }

        // Save current opp score as previous
        finalCryptos = finalCryptos || loadCache('cryptos');
        if (finalCryptos && finalFg) {
          const currentFg = finalFg[finalFg.length - 1]?.value || 0;
          const btc = finalCryptos.find(c => c.sym === 'BTC');
          const ow = optResult?.weights || null;
          const opp = computeOpportunityIndex(currentFg, finalCryptos, btc?.price || 0, btc?.ath || 0, ow);
          setPrevOppScore(prev => prev === null ? opp.score : prev);
        }
      }, []);

      useEffect(() => {
        loadAllData(true);
        const interval = setInterval(() => loadAllData(false), CONFIG.REFRESH_RATE);
        return () => clearInterval(interval);
      }, [loadAllData]);

      // Update clock every second
      useEffect(() => {
        const clockInt = setInterval(() => setTime(new Date().toLocaleTimeString('fr-FR')), 1000);
        return () => clearInterval(clockInt);
      }, []);

      const filtered = useMemo(() => {
        return cryptos.filter(c => {
          if (search && !c.sym.toLowerCase().includes(search.toLowerCase()) && !c.name.toLowerCase().includes(search.toLowerCase())) return false;
          const sent = computeSentiment(c);
          if (filter === 'BULLISH') return sent > 60;
          if (filter === 'NEUTRAL') return sent >= 40 && sent <= 60;
          if (filter === 'BEARISH') return sent < 40;
          return true;
        }).sort((a, b) => {
          if (sort === 'sentiment') return computeSentiment(b) - computeSentiment(a);
          if (sort === 'change24h') return (b.c24 || 0) - (a.c24 || 0);
          if (sort === 'volume') return (b.volume24h || 0) - (a.volume24h || 0);
          return a.id - b.id;
        });
      }, [cryptos, search, filter, sort]);

      const isLive = !loading && errors.length === 0 && lastUpdate !== 'cache';

      return (
        <div className="min-h-screen bg-dark-900 text-white noise-bg bg-grid">
          {!disclaimerAccepted && <Disclaimer onAccept={() => setDisclaimerAccepted(true)} />}
          <div className="relative z-10 max-w-[1600px] mx-auto p-4 md:p-6 lg:p-8">
            <Header isLive={isLive} time={time} stats={stats} lastUpdate={lastUpdate}/>

            {errors.length > 0 && errors.map((err, i) => (
              <ErrorBanner key={i} message={err} onRetry={loadAllData} />
            ))}

            {loading ? (
              <Loader text="Connexion aux APIs (Alternative.me + CoinGecko)..." />
            ) : (
              <>
                <div className="mb-6">
                  <FearGreedIndex value={fgVal} history={fgHist} btcHistory={btcHist}/>
                </div>

                <div className="mb-6">
                  <OpportunityIndex score={oppData.score} prevScore={prevOppScore} indicators={oppData.indicators} showDetails={showDet} setShowDetails={setShowDet} optResult={optResult}/>
                </div>

                <Filters filter={filter} setFilter={setFilter} search={search} setSearch={setSearch} sort={sort} setSort={setSort}/>

                <div className="flex items-center justify-between mb-4 text-xs">
                  <span className="text-gray-500 font-medium">
                    <strong className="text-white font-bold font-mono">{filtered.length}</strong> cryptos sur {cryptos.length}
                  </span>
                  <span className="text-gray-600 flex items-center gap-1.5">
                    <svg className="w-3.5 h-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    Cliquez pour les d√©tails ‚Ä¢ Actualisation toutes les 2 min
                  </span>
                </div>

                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-4">
                  {filtered.map((c, i) => <CryptoCard key={c.cgId || c.id} crypto={c} rank={c.id} index={i}/>)}
                </div>
              </>
            )}

            <footer className="mt-10 pt-6 border-t border-white/5 text-center space-y-2">
              <p className="text-xs text-gray-600 font-medium">
                CRYPTO SENTINEL PRO <span className="text-gray-700">‚Ä¢</span> Donn√©es r√©elles via Alternative.me & CoinCap
              </p>
              <p className="text-[10px] text-gray-700">
                ‚ö†Ô∏è Ce site ne constitue pas un conseil en investissement. Les cryptomonnaies sont des actifs √† haut risque.
              </p>
            </footer>
          </div>
        </div>
      );
    }

    ReactDOM.render(<App/>, document.getElementById('root'));
  </script>
</body>
</html>
